todo 乱序、穿插

## cap
https://juejin.cn/post/6895761455358935053

- 一致性 Consistency：等同于所有节点访问同一份最新数据；
- 可用性 Availability：每次请求都能得到非错的响应，但是不保证获取到的数据为最新数据；
- 分区容错性 Partition tolerance：以实际效果而言，分区相当于对通信的时间限制要求，系统如不能在时限内达成数据一致性，就意味着发生了分区，当前操作必须在 C 和 A 中做出选择。

根据定理，分布式系统只能满足其中的两项，不可能全部满足。
理解：想象两个节点分处分区两侧：
- 允许至少一个节点更新状态会导致数据不一致，即丧志 C 性质（就是说某一时刻点的瞬间不同步）；
- 如果为了保证数据一致性，将分区设置为一侧节点不可用，又会丧失了 A 性质；
- 除非两个节点间可互相通信，才能同时保证 A 和 C，但又会丧失 P 性质。

## 字符编码
每一个 0、1 即为计算机中存储信息的最小单元，称为 bit；byte 字节时计算机信息的计量单位，是通信和存储上的概念，8 个比特组成一个字节。
- ASCII 全称 American Standard Code For Information Interchange，美国信息交换标准码，0～127 个字符，分为控制字符与打印字符（\n,\t,a,b,c 等）。
其中 ASCII 只用了一个字节的前 7 个比特，第一位规定为 0；
- 非 ASCII 编码：例如法国、俄国需要添加自己特有的字符时，就会独立利用 ASCII 码中剩余下来的第一位，所有这些不同的编码方式里只有 128-255 这一段是不同的。而例如汉字，无法用一个字节全部表示，就需使用额外一字节来表示 256\*256 个字符。
- Unicode，如上全球存在着多种编码方式，如不提前得知一段文本的编码方式则会导致读取乱码。Unicode 就是给每一个符号都分配一个独一无二的编码。
**Unicode 只是一个符号集，只规定了符号的二进制代码，却没有规定这个二进制代码的存储规范。**
UTF-8 是一种变长编码，可以使用 1-4 个字节表示一个符号。
**UTF-8 是 Unicode 的实现方式之一，**其两条编码规则如下：
1. 对于单字节的符号，字节第一位设置为 0，后 7 位为该符号 Unicode 码，因此对于英语字母的 UTF-8 编码是和 ASCII 相同的；
2. 对于大于 1 的 n 字节符号，最左侧第一个字节的前 n 位都设为 1，第 n+1 位设为 0；后面字节的前两位一律设为 10，剩下没提及到的二进制位，全部为这个符号的 Unicode。

由上的解读为：
1. 如果一个字节的第一位是 0，则这个字节单独就是一个字符；
2. 如果第一位是 1，则连续又几个 1 就表示当前字符占用多少个字节。

http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

ANSI 全称 American National Standard Institute，美国国家标准协会。

## Linux 内核中深入了解 fork 与 clone 系统调用的区别
todo

### 内核创建进程时复制了那些数据结构？创建线程时又复制了哪些数据结构？
todo


## 线程的同步
todo：了解关键流程
https://www.guru99.com/process-synchronization.html#:~:text=Process%20Synchronization%20is%20the%20task,same%20shared%20data%20and%20resources.&text=So%20the%20change%20made%20by,accessed%20the%20same%20shared%20data.

1. 互斥量 mutex：是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量上的锁。
2. 信号量 semaphore：（上述的互斥锁只能用于一个资源的互斥访问）信号量可以实现多个同类资源的多线程互斥和同步：
- 当其值大于 0 时，表示当前可用资源量，
- 当其值小于 0 时，其绝对值表示等待使用该资源的进程数量。
- P 申请一个单位的资源；V 释放一个单位资源。
3. 读写锁 Readers-writer lock：也叫做多读者单写者锁，读操作可并发，写操作互斥。
- 当该资源被加了写锁时，其他进程的加读或写锁便会阻塞；
- 当该资源被加了读锁时，其他进程的加写锁会阻塞，加读锁会成功。


## 抢占进程调度
调度器简介 https://www.cnblogs.com/vamei/p/9364382.html
内核必须为所管理的全部进程决定，如何在进程间分配有限的计算资源，内核中安排进程执行的模块就是调度器 scheduler。
调度器可以切换进程状态，一个 Linux 进程下的进程有多种 R S D 等多种状态，但可归纳为三种基本类型：
1. 就绪 Ready：进程已获得了 cpu 以外所需的必要资源，等待到 cpu 即可执行；
2. 执行 Running：进程获得 cpu，执行进程；
3. 阻塞 Blocked：进程因为某个事件而无法执行，便会放弃 cpu 处于阻塞状态。

Linux 调度器就是 cpu 时间的管理员，负责做两件事情：
1. 选择某些就绪的进程来执行；
2. 打断某些执行中的进程，让他们变回就绪态；支持该双向转换的调度器被称为抢占式调度器。

> 抢占式内核可以保证系统的响应时间，最高优先级任务一旦就绪，便会得到 cpu 的使用权。

### 进程优先级
调度器分配 cpu 时间的基本依据是进程的优先级，根据优先级的特点可分为两类：
- 实时进程 Real-time process：优先级高，需要尽快被处理，仅能由 Linux 所创造；
- 普通进程 Normal process：优先级低、需要更长的执行时间，普通用户只能创建普通进程。

根据优先级，实时进程永远高于普通进程。进程的优先级是一个 0 到 139 的整数，数字越小优先级越高；其中实时进程占用 0-99，普通进程占用 100-139.

```bash
ps -l
```
一个普通进程的默认优先级是 120，但可用 nice 用于运行一个被修改了调度优先级的进程：
```bash
nice -n -20 vim &
```
nice 可调整值为 -20 到 19。

### O(n) 与 O(1) 调度器
以 Linux 2.6 内核作为使用分界点。
O(n) 调度器的名字来自该调度算法的时间复杂度，n 则代表系统中运行的进程个数。该调度器会在开始每个时间片时，去检查每个就绪进程的优先级，然后选择最高的去执行。
O(1) 调度器解决了前者的性能问题，每次选择要执行的进程的时间复杂度都是 1，即与进程数量无关。

### 完全公平调度器
CFS，completely Fair Scheduler 取代了 O(1) 调度器。
CFS 增加了一个**虚拟运行时 virtual time** 的概念，每次的某进程的执行，都会增加其虚拟运行时的记录。CFS 在每次选择时不按照优先级，而是选择虚拟运行时最少的进程。
CFS 会根据进程的优先级来计算一个时间片因子，针对同样一段真实时间片来计算次一次运行所需累加的 virtual time 数值。

## LRU


## 死锁 deadlock
对于两个或以上的进程，双方都在等待对方定制运行，以获取系统资源，但是没有一方提前退出时就称为死锁。
例如 p1 占用了显示器，同时又必须使用打印机；而打印机正被 p2 占用，p2 又必须使用显示器。
发生条件（只有在四个条件同时满足时才会发生，预防死锁必须破坏其中一个）：
1. 禁止抢占 no preemption：系统资源不能被强制从一个进程中退出；
2. 持有和等待 hold and wait：一个进程可以在其等待时持有系统资源；
3. 互斥 mutual exclusion：资源只能同一时分配给一个进程，无法被共享；
4. 循环等待 circular waiting：一系列进程互相持有其他进程所需要的资源。

## 原子操作
https://www.cnblogs.com/fanzhidongyzby/p/3654855.html

- 为何处理器是单条汇编指令执行？
- 被高级语言所翻译成的片段汇编语言，也会被不同进程交替执行吗？

## go 实现的线程池
https://learnku.com/docs/gobyexample/2020/work-pool-worker/6285

## 程序的编译过程
todo

## 内存

## mmu

## mmap


### 静态库、动态库
ref: https://blog.csdn.net/kang___xi/article/details/80210717

## 进程 fork 细节
ref: https://blog.csdn.net/xy010902100449/article/details/44851453

fork() 会产生一个和父进程完全相同的子进程，但此后子进程多会执行 exec 系统调用；Linux 中有“写时复制”技术，也就是说，只有在子进程空间的内容发生变化时，系统才会将父进程的内容复制一份给子进程。
在 fork 之后 exec 之前，两个进程用的是相同的物理空间，子进程的代码、数据、堆和栈都指向父进程的物理空间；也就是两者的虚拟内存地址不一样，但其对应的都是同一个物理空间。
当父\子进程中有更改段行为发生时，内核才会为子进程相应的段空间分配物理空间（段，是对虚拟内存说的吗？）；
- 如果不是因为 exec，内核会给子进程的数据段、堆栈分配相应的物理空间（父子各自拥有互不影响），而代码段子进程持续共享，因为两者完全相同。
- 如果时因为 exec，由于两者将执行不同的代码，内核也会为子进程分配单独的物理空间。

结合内存实现来看：
> fork 使子进程获得于父进程相同的数据代码空间、堆和栈，所以变量的虚拟内存地址也是相同的。每个进程都有自己的虚拟内存地址空间，不同进程的相同的虚拟地址显然可以对应不同的物理地址；因此相同的虚拟地址可呈现不同的值。

由于写时复制的机制，调度器一般会先执行子进程，因为时常子进程将立马执行 exec，将会清空和父进程共享的空间，而加载新的代码段；这就避免了发生“复制”。而若父进程先执行，则会导致子进程发生无用的复制。























